# 地址投毒

# 背景
- attacker在block chain上监听用户的交易，然后构造与该用户**最近一笔交易**的对手方的相似地址（如相同的前缀后缀），污染用户的交易历史记录，
- 从而让用户下次的转账更容易出现误操作（比如从最近交易列表中获取转账对手方地址），将资金转入黑客构造的相似地址，最终造成资金损失。
- 仅原理研究分享

# 投毒方式简介

## 前置条件
- victim地址刚收到一个链上地址X的token转入（或发出一笔对地址X的token转出）

## attacker构造攻击交易
- 【基础】构造交易——victim地址收入：
  - attacker构造一个跟地址X相似的地址Y，
  - 构造一笔Y转账给victim地址的小额token转账（如0.01 USDT）
  - 此时victim在自己的钱包交易列表中能看到：收到Y的小额资金转入的一笔交易
- 【进阶】构造交易——victim地址支出：
  - attacker构造一个跟地址X相似的地址Y
  - 构造一笔victim转账给Y的0金额token转账交易（如0USDT）
  - 此时victim在自己的钱包交易列表中能看到：转出给Y的一笔0金额交易
## victim误操作
- 此时，如果用户想给地址X发起另一笔转账，如果直接从最近的交易列表中复制地址，就会实际拿到相似地址Y（而不是地址X），导致资金损失

# 结论
- 链上token合约的实现原理允许A发起一笔交易，交易内容是 B转给C 0 个 token（实际A不知道B的私钥，B也没有给A授权任何额度）
- 地址投毒一般还会伴随一个“victim地址最近一笔交易”的**对手方**的相似地址生成
  - - 如victim用户本来收到了地址0xaaa...bbb的资金。黑客构造的地址可能就是0xaab...bbb， 如果不仔细查看可能不会注意到
- 投毒攻击并不是一个完整的攻击链条：依赖用户的“不小心”，“不注意”
- attacker构造的投毒交易的交易对手方是黑客恶意构造的前缀和后缀类似的地址。

# 在没有victim地址私钥或者approvement的场景下，仍然能构造0金额转出交易的原理
- erc20合约的transferFrom接口逻辑允许发起任何地址的转账，只要金额是0
  - 所以通过常规的transferFrom接口调用即可完成交易构造： victim地址转出0金额的token给其他地址。
  - 

# 防护措施
- 用户使用自己的地址簿保存交易对手方地址（而不是从交易历史记录中复制）
- 常规的钱包app默认屏蔽低于某个特定金额x的转账记录。
- 常规的钱包app默认屏蔽用户和“山寨”token的交易记录
  - 比如部署一个erc20合约，起名叫USDC

# 重现方式
- 直接在区块链浏览器访问transferFrom

# 相关交易和地址
- 黑客合约地址  https://polygonscan.com/address/0xAf6Be838b0d1486DFe522c7B610579d57cDe871C
- 其中一个黑客的攻击交易 https://polygonscan.com/tx/0x2a537b5a50bc541615ab8ddfeae41e87b73a7f19e40392135458c49ee9f3a0fb
- up刚分享发起的交易 https://polygonscan.com/tx/0x839307f9d9bfb5054876f1bc4899161ff6c9f9bc57170cbc81460ca85759be47

# 黑客投毒攻击的触发策略（猜测）
- 监听某些常见token的交易记录
- 如果单笔用户资金转账（或累计）超过了一定的阈值，就构造一笔对该用户的投毒交易